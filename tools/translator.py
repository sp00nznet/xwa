"""
Translator / Code Generator for XWA static recompilation.
Orchestrates the full pipeline: PE analysis -> disassembly -> lifting -> C output.
Generates split source files, dispatch table, and function headers.
"""

import os
import sys
import json
import time
from pathlib import Path

from .pe_analyze import analyze_pe, build_iat_map, read_bytes_at_va, export_json
from .disasm import Disassembler, Function
from .lifter import Lifter


def load_pe(filepath: str):
    """Load and analyze a PE file, returning everything needed for recompilation."""
    print(f"[*] Analyzing PE: {filepath}")
    info = analyze_pe(filepath)

    with open(filepath, 'rb') as f:
        pe_data = f.read()

    iat_map = build_iat_map(info)
    print(f"[*] Image base: 0x{info.image_base:08X}")
    print(f"[*] Code: 0x{info.code_start:08X} - 0x{info.code_end:08X}")
    print(f"[*] Data: 0x{info.data_start:08X} - 0x{info.data_end:08X}")
    print(f"[*] IAT entries: {len(iat_map)}")

    return info, pe_data, iat_map


def discover_functions(pe_data: bytes, info, iat_map: dict) -> dict:
    """Discover all functions in the PE's code section."""
    disasm = Disassembler(pe_data, info.image_base, info.sections)
    functions = disasm.find_functions(info.code_start, info.code_end, iat_map)
    return functions


def resolve_iat_calls(iat_map: dict, info) -> dict:
    """
    Build a map from IAT slot VA -> function pointer VA.
    For import calls like: call [0x005A9XXX] -> the address in brackets is the IAT slot.
    """
    resolved = {}
    for imp in info.imports:
        va = info.image_base + imp.iat_rva
        name = imp.name if imp.name else f"ordinal_{imp.ordinal}"
        resolved[va] = (imp.dll, name)
    return resolved


def generate_recomp_files(functions: dict, iat_map: dict, output_dir: str,
                          split_size: int = 1000, func_names: dict = None):
    """
    Generate recompiled C source files from discovered functions.

    functions: dict of addr -> Function
    iat_map: VA -> (dll, name) for import resolution
    output_dir: directory to write generated files
    split_size: max functions per source file
    func_names: optional addr -> name map for known function names
    """
    os.makedirs(output_dir, exist_ok=True)

    lifter = Lifter(iat_map=iat_map, func_names=func_names or {})

    sorted_funcs = sorted(functions.values(), key=lambda f: f.address)
    total = len(sorted_funcs)
    print(f"[*] Generating C code for {total} functions...")

    # Split into files
    file_idx = 0
    func_idx = 0
    all_func_names = []  # (addr, name) pairs for dispatch table

    while func_idx < total:
        chunk = sorted_funcs[func_idx:func_idx + split_size]
        filename = f"recomp_{file_idx:04d}.c"
        filepath = os.path.join(output_dir, filename)

        with open(filepath, 'w') as f:
            f.write(f"/* Auto-generated by XWA recompiler - DO NOT EDIT */\n")
            f.write(f"/* Functions {func_idx} to {func_idx + len(chunk) - 1} */\n")
            f.write(f"/* Address range: 0x{chunk[0].address:08X} - 0x{chunk[-1].address:08X} */\n\n")
            f.write(f'#define RECOMP_GENERATED_CODE\n')
            f.write(f'#include "recomp_types.h"\n')
            f.write(f'#include <math.h>\n')
            f.write(f'#include <string.h>\n\n')

            for func in chunk:
                try:
                    code = lifter.lift_function(func)
                    f.write(code)
                    f.write('\n\n')
                    all_func_names.append((func.address, func.name))
                except Exception as e:
                    f.write(f"/* ERROR lifting sub_{func.address:08X}: {e} */\n")
                    f.write(f"void sub_{func.address:08X}(void) {{ /* FAILED */ }}\n\n")
                    all_func_names.append((func.address, f"sub_{func.address:08X}"))

        func_idx += len(chunk)
        file_idx += 1

        if file_idx % 5 == 0:
            print(f"[*] Generated {func_idx}/{total} functions ({file_idx} files)...")

    print(f"[*] Generated {file_idx} source files in {output_dir}")

    # Generate forward declarations header
    header_path = os.path.join(output_dir, "recomp_funcs.h")
    with open(header_path, 'w') as f:
        f.write("/* Auto-generated function declarations - DO NOT EDIT */\n")
        f.write("#pragma once\n\n")
        f.write("#include <stdint.h>\n\n")
        f.write(f"/* {len(all_func_names)} recompiled functions */\n\n")
        for addr, name in all_func_names:
            f.write(f"void {name}(void);  /* 0x{addr:08X} */\n")

    # Generate dispatch table
    dispatch_path = os.path.join(output_dir, "recomp_dispatch.c")
    with open(dispatch_path, 'w') as f:
        f.write("/* Auto-generated dispatch table - DO NOT EDIT */\n\n")
        f.write('#include "recomp_types.h"\n')
        f.write('#include "recomp_funcs.h"\n\n')
        f.write(f"const recomp_dispatch_entry_t recomp_dispatch_table[] = {{\n")
        for addr, name in sorted(all_func_names, key=lambda x: x[0]):
            f.write(f"    {{ 0x{addr:08X}u, {name} }},\n")
        f.write(f"}};\n\n")
        f.write(f"const uint32_t recomp_dispatch_count = {len(all_func_names)};\n")

    print(f"[*] Generated dispatch table with {len(all_func_names)} entries")
    return all_func_names


def generate_function_list(functions: dict, output_path: str):
    """Export the function list to JSON for external tools."""
    func_list = []
    for addr, func in sorted(functions.items()):
        func_list.append({
            'address': f"0x{addr:08X}",
            'address_int': addr,
            'name': func.name,
            'size': func.size,
            'num_blocks': len(func.blocks),
            'num_instructions': func.num_instructions,
            'is_thunk': func.is_thunk,
            'calls_to': [f"0x{t:08X}" for t in sorted(func.calls_to)],
        })

    with open(output_path, 'w') as f:
        json.dump(func_list, f, indent=2)
    print(f"[*] Exported {len(func_list)} functions to {output_path}")


def generate_import_stubs(iat_map: dict, output_path: str):
    """Generate stub implementations for imported functions."""
    by_dll = {}
    for va, (dll, name) in sorted(iat_map.items()):
        by_dll.setdefault(dll, []).append((va, name))

    with open(output_path, 'w') as f:
        f.write("/* Import bridge stubs - manual implementation needed */\n\n")
        f.write('#include "recomp_types.h"\n\n')

        for dll, imports in sorted(by_dll.items()):
            f.write(f"\n/* ===== {dll} ===== */\n\n")
            for va, name in imports:
                f.write(f"/* 0x{va:08X} */ void bridge_{name}(void) {{\n")
                f.write(f"    /* TODO: implement {dll}::{name} */\n")
                f.write(f"    STUB(\"{dll}::{name}\");\n")
                f.write(f"}}\n\n")

    print(f"[*] Generated import stubs for {sum(len(v) for v in by_dll.values())} imports")


def main():
    import argparse
    parser = argparse.ArgumentParser(description='XWA Static Recompiler')
    parser.add_argument('pe_file', help='Path to xwingalliance.exe')
    parser.add_argument('--output', '-o', default='src/game/recomp/gen',
                        help='Output directory for generated code')
    parser.add_argument('--split', type=int, default=1000,
                        help='Max functions per source file')
    parser.add_argument('--all', action='store_true',
                        help='Run full pipeline')
    parser.add_argument('--analyze-only', action='store_true',
                        help='Only run PE analysis')
    parser.add_argument('--functions-json', default=None,
                        help='Export function list to JSON')
    parser.add_argument('--stubs', default=None,
                        help='Generate import stub file')
    parser.add_argument('--pe-json', default=None,
                        help='Export PE analysis to JSON')

    args = parser.parse_args()

    start_time = time.time()

    # Step 1: Analyze PE
    info, pe_data, iat_map = load_pe(args.pe_file)

    if args.pe_json:
        export_json(info, args.pe_json)

    if args.analyze_only:
        from .pe_analyze import print_summary
        print_summary(info)
        return

    # Step 2: Discover functions
    print(f"\n[*] Phase 2: Function discovery...")
    functions = discover_functions(pe_data, info, iat_map)

    if args.functions_json:
        generate_function_list(functions, args.functions_json)

    if args.stubs:
        generate_import_stubs(iat_map, args.stubs)

    if args.all:
        # Step 3: Generate recompiled C code
        print(f"\n[*] Phase 3: Code generation...")
        all_funcs = generate_recomp_files(
            functions, iat_map, args.output,
            split_size=args.split,
        )

        elapsed = time.time() - start_time
        print(f"\n[*] Complete! {len(functions)} functions recompiled in {elapsed:.1f}s")
        print(f"[*] Output: {args.output}")
        print(f"[*] Generated files: {len(all_funcs) // args.split + 1} source + dispatch + header")

    elapsed = time.time() - start_time
    print(f"\n[*] Total time: {elapsed:.1f}s")


if __name__ == '__main__':
    main()
